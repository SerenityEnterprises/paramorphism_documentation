# Конфигурация

## Ввод & Вывод

`input` содержит путь, где находится ваш скомпилированный файл, в то время как `output` содержит путь, куда файл после обфускации будет сохранен.

Эти пути могут быть как относительными, в зависимости от того, где находится файл конфигурации, так и абсолютными, в зависимости от того, начинается ли класс с абсолютного базового пути (например, `/` в нормальных операционных системах или буква диска вроде `C:/` в Windows).

**Пример:**

```yml
input: path/to/application.jar
output: obfuscated-application.jar
```

## Библиотеки

В Paramorphism'е есть два способа определить библиотеки: это параметры `libraries` и `maven_libraries`. `libraries` — это простой список файлов JAR (или каталогов файлов JAR), а `maven_libraries` - это спецификация используемых maven-подобных структур. Наиболее распространенное использование `maven_libraries` — это каталог .m2 в корневой папке пользователя.

Чтобы начать использовать `libraries`, просто перечислите JAR файлы и/или каталоги, которые вы хотите туда включить. Как и `input` и `output`, их пути находятся там же, где и путь файла конфигурации.

**Пример: `libraries`**

```yml
libraries:
  - my_library-1.0.jar
  - libs/google/guava.jar
  - libs/eclipse/ # Все JAR файлы находящиеся внутри директории libs/eclipse/
```

Чтобы использовать `maven_libraries`, вам нужно объявить базовые каталоги, соответствующие списку вашего приложения. Также, к файлу конфигурации относятся и базовые каталоги.

В будущем планируется поддержка HTTPS для базовых каталогов maven.

**Пример: `maven_libraries`**

```yml
maven_libraries:
  /home/myself/.m2/:
    - "com.google.code.gson:gson:2.8.5"
    - "io.netty:netty-all:4.1.0.Final"

  path/to/another/maven:
    - "com.example:proprietary-library:1.0.0"
```

::: warning
Для того, чтобы ремаппер работал правильно, все библиотеки, являющиеся зависимостями приложения, должны быть определены в конфигурационном файле.
:::

## Маскировка элементов

Маска элемента определяет, какие элементы должны быть включены на этапе обфускации. Глобальная маска определяется параметром `mask` в файле конфигурации и контролирует классы, к которым может обращаться любая стратегия обфускации.

Элемент маскировки имеет два параметра: _including_ и _excluding_. По умолчанию все элементы включены. Если какие-либо элементы определены в списке `include`, то **включаются вписанные в него** элементы. Затем все элементы, соответствующие списку `exclude`, также исключаются.

Примером случаев, когда использование масок не требуется, являются классы, которые подтвергаются интенсивной работе с рефлексией, например, самоанализ имен полей при использовании сериализуемых Java-программ или что-то вроде Gson.

```yml
mask:
  include:
    - com/example/myproject/
    - org/business/proprietarylibrary/
  exclude:
    - com/example/myproject/beans/serializable/
    - com/example/myproject/config/ConfigurationJSONBean
```

### Правила соответствий

`include` и `exclude` являются списками параметра _matching rules_. Это довольно простая концепция:

- Если правило заканчивается на `/`, оно будет соответствовать любому, начинающемуся с правила. Например, правилу `path/rule/` соответствует `path/rule/one`, `path/rule/two`, однако `any/else/asdf`, уже нет.

- Если правило заканчивается на `*`, оно будет действовать как пустой, или любой другой знак и их безграничное количество. Например, правилу `wildcard/rule*` соответствует `wildcard/rule/one`, `wildcard/ruletwothreefour/five`, но уже не соответствует `wildcard/everythingelse`

- В иных других случаях, правило соответствует чему-либо идентичному самому себе.

## Флаги

Флаги — это простые переменные, типа 'boolean' для изменения работы алгоритма обфускатора.

В настоящее время в Paramorphism'e реализованы следующие флаги:

- `corruption`
- `anti_decompression`
- `kotlin`

### Искажение (Corruption)

Флаг 'corruption' указывает обфускатору выдавать файл JAR, который технически недействителен, но выполняется в любом случае из-за снисходительного парсинга JAR файла.

С данным флагом, большинство инструментов анализа оказываются нерабочими, за исключением тех, которые специально созданы для обфускации Paramorphism.

### Анти-Декомпрессия

Флаг 'anti_decompression' пытается обеспечить гарантию того, что отдельные классы не могут быть извлечены из файла JAR для анализа.

### Kotlin

Флаг 'kotlin' указывает обфускатору включить конкретные стратегии запутывания для языка программирования Kotlin. Например, специфичная для Kotlin стратегия может исключить отладочную информацию, уникальную для компилятора Kotlin.

В настоящее время, использование флага `kotlin` может испортить работу программ, использующих библиотеку `kotlin-reflect`. (Обратите внимание, что стандартная рефлекция Java не зависит от флага).

## Стратегии

В Paramorphism могут быть настроены индивидуальные стратегии.

Все стратегии имеют как минимум два настраиваемых параметра: `enabled` и `mask`

`enabled` определяет, будет ли стратегия обфускатора использоваться при обфускации вышей программы, и является булевым значением. Значение по умолчанию «enabled» имеет значение true для всех стратегий обфускатора, но некоторые стратегии управляются с помощью [конфигурационных флагов](#Флаги).

`mask` – это специфичная маска, которая определяет, к каким классам будет применяться стратегия обфускатора. Обратите внимание, что исключения из глобальной маски не могут быть отменены включением из локальной маски.

Используя стратегию 'Field Access Indirection' в качестве примера, мы устанавливаем для 'enabled' значение true и отключаем стратегию для класса с высокой производительностью:

```yml
field_access_indirection:
  enabled: true # Только для демонстрационных целей; т.к. значение true является стандартным параметром
  mask:
    exclude:
      - com/example/project/ASuperPerformanceCriticalClass
```

Ниже приведены стратегии которые уже присутствуют в Paramorphism:

- `debug_info_scrubbing`
- `kotlin_metadata_scrubbing`
- `kotlin_intrinsics_concealment`
- `remapper`
- `method_call_indirection`
- `field_access_indirection`
- `string_indirection`

По мере реализации большего числа стратегий вполне вероятно, что некоторые разработают свои собственные параметры.

## Генерация имен

Генератор имен используется во всем обфускаторе, но его наиболее очевидное применение - в ремаппинге. Генератор имен работает с четырьмя типами элементов: пакеты, классы, поля и методы.

Существует три различных параметра генерации имен: словари, префиксы и суффиксы.

Параметры можно настроить так, чтобы он воздействовал на любой из типов элементов следующим образом:

```yml
name_generation:
  [facet]:
    all: ...
    packages: ...
    classes: ...
    # fields: ... # Поскольку мы опустили данное поле, его значение по умолчанию равно 'all'
    methods: ...
```

### Словари

На данный момент, Paramorphism включает в себя четыре различных словаря:

- `alphabet`
- `alphabet_upper`
- `java_keywords`
- `enterprise`

```yml
name_generation:
  dictionaries:
    all: alphabet
    classes: enterprise
```

### Префиксы

Префиксы являются константной строкой, применяемой к началу каждого сгенерированного имени:

```yml
name_generation:
  prefixes:
    classes: MyProjectClass
```

### Суффиксы

Суффиксы — это константа, которая применяется к концу каждого сгенерированного имени:

```yml
name_generation:
  suffixes:
    fields: "[]"
```

### Обесценивание

К тому же, генератор имен может принимать параметр 'inflation'. Это позволяет обфускатору генерировать определенное количество случайных дополнительных частей имени, в зависимости от значения параметра 'inflation'. Например, имя 'a' с параметром 'inflation' равным 0, может быть сгенерировано как 'fdgjia' с параметром 'inflation' равным 5.
